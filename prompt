#! /usr/bin/env bash
#-------------------------------------------------------------------------------
# File        : .prompt
# Author      : Lewis Russell
# Description : Very useful zsh/csh/tcsh/bash prompt for seamless use with Git
#-------------------------------------------------------------------------------

# The prompt will check the git config for branch.<branch>.upstream
# for a branch this branch aims to be merged into, e.g:
#
# ```
# git config branch.mybranch.upstream upstream/main
# ```

SHELL="$1"
RET_CODE="$2"
FAST="$3"
CMD_TIME="$4"

#-------------------------------------------------------------------------------
# Init
#-------------------------------------------------------------------------------
# Unalias all aliases
unalias -a

#-------------------------------------------------------------------------------
# Globals
#-------------------------------------------------------------------------------
CHECKOUT=""
CHECKOUT_IS_TAG=0
STAGED_CHANGED=""
STAGED_ADDED=""
STAGED_DELETED=""
CONFLICTS=""
UNSTAGED_CHANGED=""
UNSTAGED_DELETED=""
UNTRACKED=""
STASHES=""
SUBMODULE_UNSYNC=""
SUBMODULE_UNINIT=""
LOCAL_BRANCHES=""

#-------------------------------------------------------------------------------
# Attributes, Colours & Constants
#-------------------------------------------------------------------------------
if [ "$SHELL" == "bash" ]; then
    C_START='\['
    C_END='\]'
    P_USER='\u'
    P_HOST='\H'
else # csh, tcsh and zsh
    C_START='%{'
    C_END='%}'
    P_USER='%n'
    P_HOST='%m'
fi

# reverse="${c_start}\\e[3;35m${c_end}"
# underlined="${c_start}\\e[4;35m${c_end}"
# dim="${c_start}\\e[10;35m${c_end}"
GRAY="$C_START\\e[0;90m$C_END"
RED="$C_START\\e[0;31m$C_END"
GREEN="$C_START\\e[0;32m$C_END"
YELLOW="$C_START\\e[0;33m$C_END"
BLUE="$C_START\\e[0;34m$C_END"
MAGENTA="$C_START\\e[0;35m$C_END"
CYAN="$C_START\\e[0;36m$C_END"
WHITE="$C_START\\e[0;37m$C_END"
END="$C_START\\e[0m$C_END" # This is needed at the end.

# Emit an OSC-133;A sequence before each prompt.
if [ "$SHELL" == "zsh" ]; then
    OSC133_START="\e]133;A\e\\"
else
    OSC133_START=""
fi

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
# FANCY_PROMPT_TIMEOUT

# FANCY_PROMPT_USE_SYMBOLS
#     NOTE: this is a multi-char symbol which causes glitches with zsh tab
#     completion. e.g. vim <tab> if locale is not setup correctly.
#     export LC_CTYPE=en_US.UTF-8

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------
var_enabled() {
    [[ -n "$1" && "$1" != 0 ]]
}

check_error() {
    local ret_code="$1"
    local code="$2"
    if [ "$ret_code" != 0 ]; then
        echo "ERROR $code:$ret_code"
        exit 1
    fi
}

check_command() {
    command -v "$1" &> /dev/null
}

convertsecs() {
    d=$((${1} / 86400))
    h=$((${1} / 3600))
    m=$((${1} % 3600 / 60))
    s=$((${1} % 60))
    if ((d!=0)); then
        printf "%dd %dh %dm %ds" "$d" "$h" "$m" "$s"
    elif ((h!=0)); then
        printf "%dh %dm %ds" "$h" "$m" "$s"
    elif ((m!=0)); then
        printf "%dm %ds" "$m" "$s"
    else
        printf "%ds" "$s"
    fi
}

vercomp() {
    if [[ "$1" == "$2" ]]; then
        return 0
    fi

    local -a ver1 ver2

    IFS='.' read -r -a ver1 <<< "$1"
    IFS='.' read -r -a ver2 <<< "$2"

    local i

    for ((i=0; i<${#ver1[@]} || i<${#ver2[@]}; i++)); do
        [[ -z ${ver1[i]} ]] && ver1[i]=0
        [[ -z ${ver2[i]} ]] && ver2[i]=0
        if ((ver1[i] > ver2[i])); then
            return 0
        elif ((ver1[i] < ver2[i])); then
            return 1
        fi
    done

    return 1
}

git_vercomp() {
    if [ -z "$GIT_VERSION" ]; then
        GIT_VERSION=$(git --version | awk '{print $3}')
    fi

    vercomp "$GIT_VERSION" "$1"
}

set_git_checkout() {
    if ! git_vercomp "1.7.2"; then
        CHECKOUT="!$(git rev-parse --abbrev-ref HEAD)"
        return
    fi

    # shellcheck disable=2207
    declare -a rp=($(git rev-parse --path-format=absolute --abbrev-ref HEAD --git-dir --git-common-dir '@{u}'))

    local checkout=${rp[0]}

    local remote=$(git config --get branch."$checkout".remote || true)
    local upstream=$(git config --get branch."$checkout".upstream || true)

    if [[ -z $upstream ]]; then
        local gh_resolved=$(git config --get remote.upstream.gh-resolved || true)
        if [[ -n $gh_resolved ]]; then
            upstream="upstream/$(git remote show upstream | sed -n '/HEAD branch/s/.*: //p')"
        fi
    fi

    if [[ $upstream != "" && "$remote/$checkout" != "$upstream" ]]; then
        read -ra AB <<< "$(git rev-list --left-right --count "$upstream"...HEAD)"
        CHECKOUT_UPSTREAM="$upstream"
        COMMITS_BEHIND_UPSTREAM=${AB[0]}
        COMMITS_AHEAD_UPSTREAM=${AB[1]}
    fi


    local git_dir=${rp[1]}
    local git_common_dir=${rp[2]}
    local remote_full=${rp[3]}
    local push_branch=${remote_full#*/}  # upstream/main -> main

    if [[ $push_branch == "" ]]; then
        local merge; merge=$(git config --get branch."$checkout".merge)
        push_branch="$remote/$merge"
    fi

    CHECKOUT=$checkout

    if [[ "$CHECKOUT" =~ HEAD ]]; then
        local tag

        # Show short hash if not on a branch
        CHECKOUT=$(git rev-parse --short HEAD)

        if [[ -d "$git_dir/rebase-merge" || -d "$git_dir/rebase-apply" ]]; then
            # Are we rebasing?
            CHECKOUT="$CHECKOUT(rebasing)"
        elif [[ -f "$git_dir/BISECT_START" ]]; then
            # Are we bisecting?
            CHECKOUT="$CHECKOUT(bisecting)"
        elif tag=$(git describe --candidates=1 --exact-match); then
            CHECKOUT=$tag
            CHECKOUT_IS_TAG=1
        fi
    fi

    if [ -n "$push_branch" ]; then
        if [ "$CHECKOUT" != "$push_branch" ]; then
            CHECKOUT="$CHECKOUT->$push_branch"
        fi
    elif [[ $CHECKOUT_IS_TAG != 1 ]]; then
        CHECKOUT="$CHECKOUT!"
    fi

    if [[ "$git_dir" != "$git_common_dir" ]]; then
        CHECKOUT="[worktree]$CHECKOUT"
    fi
}

parse_porcelain_info() {
    local porcelain_info=$1
    # porcelain info should be common between git
    if [ "$porcelain_info" == "?" ]; then
        return
    fi

    STAGED_CHANGED=0
    STAGED_ADDED=0
    STAGED_DELETED=0
    UNSTAGED_DELETED=0
    UNSTAGED_CHANGED=0
    UNTRACKED=0
    CONFLICTS=0

    while IFS= read -r line ; do
        if [[ $line =~ ^[MTRC][\ MD] ]]; then ((STAGED_CHANGED   ++)); fi
        if [[ $line =~ ^A[\ MD]      ]]; then ((STAGED_ADDED     ++)); fi
        if [[ $line =~ ^D\           ]]; then ((STAGED_DELETED   ++)); fi
        if [[ $line =~ ^[\ MARC]D    ]]; then ((UNSTAGED_DELETED ++)); fi
        if [[ $line =~ ^[\ MARC]M    ]]; then ((UNSTAGED_CHANGED ++)); fi
        if [[ $line =~ ^[?][?]       ]]; then ((UNTRACKED        ++)); fi
        if [[ $line =~ ^[DU][DU] ]] || [[ $line =~ ^[AU][AU]    ]]; then
            ((CONFLICTS++));
        fi
        # DD  unmerged, both deleted
        # AU  unmerged, added by us
        # UD  unmerged, deleted by them
        # UA  unmerged, added by them
        # DU  unmerged, deleted by us
        # AA  unmerged, both added
        # UU  unmerged, both modified
    done <<< "$porcelain_info"
}

get_local_branches() {
    # Local branches that do not have an upstream of the same name
    if git_vercomp "2.4.0"; then
        git branch -vv --format='%(refname:strip=2)#%(upstream:strip=3)' | grep -vcE '([^#]+)#\1'
    else
        git branch | grep -cv master
    fi
}

if ! command -v timeout &> /dev/null; then
    timeout() { perl -e 'alarm shift; exec @ARGV' "$@"; }
fi

get_git_info() {
    if git_vercomp "1.7.2"; then
        timeout "$TIMEOUT" git status --untracked-files=normal --branch --porcelain --ignore-submodules
    else
        timeout "$TIMEOUT" git status --untracked-files=normal --porcelain
    fi
}

set_git_info() {
    local info
    info=$(get_git_info)

    local error
    error=$(check_error "$?" "2")

    parse_porcelain_info "$info"

    local submodule_info
    submodule_info=$(timeout "$TIMEOUT" git submodule status --recursive 2> /dev/null)
    if [ "$submodule_info" != "" ]; then
        SUBMODULE_UNSYNC=$(grep -cE '^\+' <<< "$submodule_info")
        SUBMODULE_UNINIT=$(grep -cE '^-'  <<< "$submodule_info")
    fi

    if [ "$error" != "" ]; then
        return
    fi

    # branch_info=$(head -1 <<< "$info")
    # COMMITS_AHEAD=$(grep 'ahead'  <<< "$branch_info" | sed -E  's/.*ahead ([0-9]+).*/\1/g')
    # COMMITS_BEHIND=$(grep 'behind' <<< "$branch_info" | sed -E 's/.*behind ([0-9]+).*/\1/g')
    # error=$(check_error "$?" "4")
    COMMITS_BEHIND=$(git rev-list --count --left-only "HEAD@{upstream}...HEAD")
    COMMITS_AHEAD=$(git rev-list --count "HEAD@{upstream}..HEAD")

    if [ "$error" != "" ]; then
        return
    fi

    # # MacOS can add leading whitespace in wc output so pass through tr
    # STASHES=$(git stash list | wc -l | tr -d ' ')
    STASHES=$(git rev-list --walk-reflogs --ignore-missing --count refs/stash)

    # Local branches that do not have an upstream of the same name
    LOCAL_BRANCHES=$(get_local_branches)

    set_git_checkout
}

build_section() {
    local colour=$1
    local symbol=$2
    local value=$3
    if [[ $value && $value != 0 ]]; then
        echo "$colour$symbol$value"
    fi
}

get_scm_prompt() {
    if [[ $CHECKOUT == "" ]]; then
        printf "%s" "$GRAY...$GRAY"
        return
    fi

    local src_ctrl=""
    local co_sym

    if var_enabled "$FANCY_PROMPT_USE_SYMBOLS"; then
        if [[ $CHECKOUT_IS_TAG == 1 ]]; then
            co_sym=""
        else
            co_sym=""
        fi
    fi

    src_ctrl+=$(build_section "$GRAY"   "$co_sym" "$CHECKOUT"      )
    src_ctrl+=$(build_section " $WHITE"   ↑       "$COMMITS_AHEAD" )
    src_ctrl+=$(build_section " $WHITE"   ↓       "$COMMITS_BEHIND")
    if [[ $CHECKOUT_UPSTREAM != "" ]]; then
        src_ctrl+=" $GRAY("
        src_ctrl+=$(build_section "$GRAY"   "$co_sym" "$CHECKOUT_UPSTREAM"      )
        src_ctrl+=$(build_section " $WHITE"   ↑       "$COMMITS_AHEAD_UPSTREAM" )
        src_ctrl+=$(build_section " $WHITE"   ↓       "$COMMITS_BEHIND_UPSTREAM")
        src_ctrl+="$GRAY)"
    fi
    src_ctrl+=$(build_section " $WHITE"          "$SUBMODULE_UNINIT")
    src_ctrl+=$(build_section " $RED"            "$SUBMODULE_UNSYNC")
    src_ctrl+=$(build_section " $GREEN"   ●       "$STAGED_CHANGED"  )
    src_ctrl+=$(build_section " $GREEN"   +       "$STAGED_ADDED"    )
    src_ctrl+=$(build_section " $GREEN"   -       "$STAGED_DELETED"  )
    src_ctrl+=$(build_section " $RED"     ✖       "$CONFLICTS"       )
    src_ctrl+=$(build_section " $RED"     +       "$UNSTAGED_CHANGED")
    src_ctrl+=$(build_section " $RED"     -       "$UNSTAGED_DELETED")
    # src_ctrl+=$(build_section " $magenta" +        "$UNTRACKED"       )
    src_ctrl+=$(build_section " $MAGENTA" …       "$UNTRACKED"       )
    src_ctrl+=$(build_section " $RED"     ⚑       "$STASHES"         )
    src_ctrl+=$(build_section " $YELLOW"         "$LOCAL_BRANCHES"  )

    printf "%s" "$GRAY$src_ctrl$GRAY"
}

get_prompt_arrow() {
    local ret_colour=$1
    local arrow
    if var_enabled "$FANCY_PROMPT_USE_SYMBOLS"; then
        arrow="❯"
    else
        arrow=">"
    fi

    echo "$ret_colour$arrow$END"
}

toboolean() {
    if "$@"; then
        echo true
    else
        echo false
    fi
}

main() {
  TIMEOUT=${FANCY_PROMPT_TIMEOUT-6}

  if var_enabled "$FANCY_PROMPT_USE_NERD_SYMBOLS"; then
      FANCY_PROMPT_USE_SYMBOLS=1
  fi

  if [[ $TMUX ]]; then
      # capture the target window before running set_git_info in case the user
      # switches windows before the prompt is updated.
      TMUX_TARGET_WIN="$(tmux display-message -p '#I')"
  fi

  #-------------------------------------------------------------------------------
  # Source Control
  #-------------------------------------------------------------------------------

  local in_gitdir
  local in_bare_gitdir
  local orig_pwd; orig_pwd=$(pwd)

  # If we a located somewhere deep in .git/.. then navigate out of it to prevent
  # the error: "fatal: This operation must be run in a work tree"
  in_gitdir=$(pwd | toboolean grep -q "\\.git\(/.*\)\?$")
  if $in_gitdir; then
      in_bare_gitdir=$(git rev-parse --is-bare-repository)
      cd "$(pwd | sed -E 's%[^/]*\.git(\/.*)?$%%g')" || exit
  fi

  # Return 'true' or 'false' which can be directly evaluated
  local in_git
  in_git=$(git rev-parse --is-inside-work-tree 2> /dev/null || echo false)

  local prompt_info=""
  if $in_git; then
      if ((!FAST)); then
          set_git_info
      fi
      prompt_info+="$(get_scm_prompt)"
  fi

  if $in_bare_gitdir; then
      dir=$(basename $orig_pwd)
  elif $in_gitdir; then
      dir=$(basename "$(git rev-parse --show-toplevel)")/$(sed -E 's/.*\/([^/]*\.git(\/.*)?)/\1/' <<< "$orig_pwd")
  elif $in_git; then
      dir=$(basename "$(git rev-parse --show-toplevel)")/$(git rev-parse --show-prefix)
      dir=${dir%?}  # Remove last /
  elif [ "$SHELL" == "bash" ]; then
      dir='\W'
  else
      dir='%c'
  fi

  #-------------------------------------------------------------------------------
  # Prompt
  #-------------------------------------------------------------------------------
  local prompt="${BLUE}${P_HOST}:${CYAN}${P_USER}:${GREEN}$dir "

  local ret_colour
  if [ "$RET_CODE" -eq 0 ]; then
      ret_colour="$CYAN"
  else
      ret_colour="$RED"
  fi

  local prompt_time=''
  if [[ $CMD_TIME ]] && ! [[ $CMD_TIME == 0* ]]; then
      prompt_time="$GRAY$(convertsecs "$CMD_TIME")"
  fi

  if $in_git; then
      if [[ $CHECKOUT != "" ]]; then
          name="$(git rev-parse --show-toplevel | xargs basename)"
          if [[ $TMUX ]]; then
              tmux rename-window -t "$TMUX_TARGET_WIN" "$name#[fg=colour8][$CHECKOUT]"
          fi
      fi
  elif [[ $TMUX ]]; then
      tmux rename-window -t "$TMUX_TARGET_WIN" "$(basename "$orig_pwd")"
  fi

  printf "%s\n$OSC133_START%s%s\n" "$prompt_time" "$prompt" "$prompt_info"
  printf "%s " "$(get_prompt_arrow $ret_colour)"
}

main
